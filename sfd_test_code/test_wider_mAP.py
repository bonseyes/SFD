import argparse
import numpy as np
import os
import os.path
import scipy.io as sio


def parse_det_file(path):
    """
    Given a path for a single detection file, 
    returns the list of faces in it:

    The returned list has shape (detected_faces, 5),
    where the columns correspond to (xmin, ymin, width, height, score) 
    The faces are sorted in descending order (i.e. bigger score first)
    """
    with open(path, 'r') as f:
        lines = [[float(i) for i in row.strip().replace('\n', '').split(' ')] for row in f.readlines()[2:]]

    faces = np.array(lines)
    sorted_faces = faces[faces[:, 4].argsort()[::-1]]
    return sorted_faces


def parse_detected_faces(path):
    """
    Given a root folder where the detected faces (obtained, for example, with test_wider.py),
    parse the files and return a dict with all the data

    The root folder must have the following structure:

    root_folder/
        0--Parade/
            0_Parade_marchingband_1_1004.txt
            0_Parade_marchingband_1_1045.txt
            .
            .
            .
        1--Handshaking/
            1_Handshaking_Handshaking_1_107.txt
            1_Handshaking_Handshaking_1_134.txt
            .
            .
            .
        .
        .
        .

    Returns:
    {
        '0--Parade': {
            '0_Parade_marchingband_1_1004': [
                                             [8.53600000e+02, ..., 6.10000000e-02],
                                             [1.84000000e+02, ..., 6.00000000e-02],
                                             ...
                                            ],
            '0_Parade_marchingband_1_1045': [...]
        },
        ...
    }

    """
    result = {}
    for root, dirs, files in os.walk(path):
        category = os.path.basename(root)
        faces = files
        result[category] = {f.replace('.txt', ''): parse_det_file(os.path.join(path, category, f)) for f in faces}

    return result


def parse_gt_faces(path):
    """
    Given a Matlab .mat file with the corresponding groundtruth faces, 
    this function loads it and returns a dictionary like the one in
    parse_detected_faces().

    I recommend loading the .mat file in a Python interpreter to actually 
    understand its structure and therefore this code.
    """
    mat_faces = sio.loadmat(path) 
    categories = [str(event[0]) for event in mat_faces['event_list'].flatten()]
    files = [[str(f[0]) for f in files.flatten()] for files in mat_faces['file_list'].flatten()]
    faces = [[[list(face) for face in image[0]] for image in event[0]] for event in mat_faces['face_bbx_list']]
    files_faces = [{k: np.array(v) for k, v in zip(fil, faces[i])} for i, fil in enumerate(files)]
    result = dict(zip(categories, files_faces))
    return result


def compute_mAP(det_faces, gt_faces):
    """
    Given dicts of detected faces and groundtruth faces
    compute the mAP.

    The dicts are generated by parse_detected_faces and parse_gt_faces 
    respectively.
    """


if __name__ == '__main__':
    """
    Usage:

    python2.7 test_wider_mAP.py -p WIDER_FACE/eval_tools_old-version/sfd_val\
           -m WIDER_FACE/eval_tools_old-version/ground_truth/wider_easy_val.mat
    """
    parser = argparse.ArgumentParser(description='Code to check mAP metric for WIDER FACE obtained with SFD.')
    parser.add_argument('-p', '--path', type=str, help='Folder where the detected faces (validation set) are.', required=True)
    parser.add_argument('-m', '--matlab-faces', type=str, help='.mat file with the groundtruth faces. Can be easy, medium or hard.', required=True)
    args = parser.parse_args()

    dets_path = args.path
    gt_path = args.matlab_faces

    det_faces = parse_detected_faces(dets_path)
    gt_faces = parse_gt_faces(gt_path)
    # TODO: complete with mAP computation
