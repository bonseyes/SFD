import numpy as np


THRESHOLDS = 1000


def normalize_scores(det_faces):
    """
    Normalize scores between 0 and 1
    """
    max_score = 0
    min_score = 100
    for event in det_faces:
        for img in det_faces[event]:
            max_score = max(det_faces[event][img][:, 4].max(), max_score)
            min_score = min(det_faces[event][img][:, 4].min(), min_score)

    for event in det_faces:
        for img in det_faces[event]:
            det_faces[event][img][:, 4] = (det_faces[event][img][:, 4] - min_score) / float(max_score - min_score)

    return det_faces
            

def compute_overlaps(rect, gt):
    """
    Given a single rectangle and a list of groundtruth rectangles,
    compute a list of the IoU for each gt rectangle
    """
    xmin = np.round(np.maximum(gt[:, 0], rect[0])).astype(int)
    ymin = np.round(np.maximum(gt[:, 1], rect[1])).astype(int)
    xmax = np.round(np.minimum(gt[:, 2], rect[2])).astype(int)
    ymax = np.round(np.minimum(gt[:, 3], rect[3])).astype(int)

    w = np.maximum(xmax - xmin + 1, 0)
    h = np.maximum(ymax - ymin + 1, 0)
    inter_area = w * h

    rect_area = (rect[2] - rect[0] + 1) * (rect[3] - rect[1] + 1)
    gt_areas = (gt[:, 2] - gt[:, 0] + 1) * (gt[:, 3] - gt[:, 1] + 1)

    ious = inter_area / (rect_area + gt_areas - inter_area)
    return ious


def compute_pr(dets, gt_dets, gt_keep):
    """
    dets, gt_dets are np.arrays(dtype=float) that have
    shape (num_detections, 4)

    This function assumes `dets` has the detections sorted
    in descending order according to a score.

    Returns count of cumulative TP (pred_recalls), and a list of proposals that need to be ignored
    """
    # recalls keeps track of all the gt boxes that became
    # TP detections. We do not count the ignored gt boxes
    # in the metric. If a box was detected, it has 1, otherwise 
    # its value in this array will be 0.
    recalls = np.zeros(len(gt_dets)) 
    # Counts cumulative TP for each detection
    pred_recalls = np.zeros(len(dets))
    # proposals keeps track of all the detections:
    # - The ones that overlap with gt boxes that are ignored at this 
    #   difficulty level (-1)
    # - The ones that are either TP or FP (1)
    proposals = np.ones(len(dets))

    for i, det in enumerate(dets):
        ious = compute_overlaps(det, gt_dets)
        idx = np.argmax(ious)
        max_iou = ious[idx]
        if max_iou >= 0.5:
            if idx not in gt_keep:
                recalls[idx] = -1
                proposals[i] = -1
            elif recalls[idx] == 0:
                recalls[idx] = 1
        true_positives = np.sum(recalls == 1)
        pred_recalls[i] = true_positives

    return pred_recalls, proposals


def compute_tp_fp(dets, pred_recalls, proposals):
    interp_pr = np.zeros((THRESHOLDS, 2))

    for i, r in enumerate(np.arange(0, 1, 1 / float(THRESHOLDS))):
        t = i + 1
        idx = np.where(dets[:, 4] >= r)[0]
        if idx.size == 0:
            interp_pr[t - 1, 0] = 0
            interp_pr[t - 1, 1] = 0
        else:
            min_idx = idx[-1]
            # amount of TP and FP for this threshold, for this image
            interp_pr[t - 1, 0] = np.sum(proposals[:min_idx + 1] == 1)
            # amount of TP for this threshold, for this image
            interp_pr[t - 1, 1] = pred_recalls[min_idx]

    return interp_pr


def compute_prec_rec(det_faces, gt_faces, gt_keep):
    """
    Given dicts of detected faces and groundtruth faces
    compute the mAP.

    The dicts are generated by parse_detected_faces and parse_gt_faces 
    respectively.
    """
    all_interp_pr = []
    count = 0
    n_imgs = 0
    for event in det_faces:
        for img in det_faces[event]:
            n_imgs += 1
            img_faces = det_faces[event][img]
            img_gt_faces = gt_faces[event][img]
            img_gt_keep = gt_keep[event][img]
            count += len(img_gt_keep)

            if img_faces.size == 0 or img_gt_faces.size == 0:
                continue

            pred_recalls, proposals = compute_pr(img_faces, img_gt_faces, img_gt_keep)
            interp_pr = compute_tp_fp(img_faces, pred_recalls, proposals)
            all_interp_pr.append(interp_pr)

    tpfp = np.zeros(THRESHOLDS)
    tp = np.zeros(THRESHOLDS)
    for i in range(n_imgs):
        tpfp = tpfp + all_interp_pr[i][:, 0]
        tp = tp + all_interp_pr[i][:, 1]

    prec = tp / tpfp
    recall = tp / float(count)
    return prec, recall


def correct_pr_curve(precision, recall):
    """
    We will consider a corrected PR curve where for 
    each point (p, r), if there exists another point
    (p', r') such that p' > p and r' >= r, we set p
    to the maximum of those points
    """
    off_pre = np.concatenate(([0], precision[::-1] , [0]))
    off_rec = np.concatenate(([0], recall[::-1], [1]))

    for i in range(len(off_pre) - 2, -1, -1):
        off_pre[i] = max(off_pre[i], off_pre[i + 1])

    idx = np.where(off_rec[1:] != off_rec[:-1])[0] + 1

    return off_pre, off_rec, idx


def compute_ap(precision, recall):
    precision, recall, idx = correct_pr_curve(precision, recall)
    return np.sum((recall[idx] - recall[idx - 1]) * precision[idx])
